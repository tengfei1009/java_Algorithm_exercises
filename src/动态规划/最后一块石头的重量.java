package 动态规划;

public class 最后一块石头的重量 {
    public int lastStoneWeightII(int[] stones) {
        int sum =0;
        for (int i : stones) {
            sum+=i;
        }
        //当背包容量最接近一半的时候,用一半减去另一半就是最大值   分成两堆,最优的情况就是两堆相等等于0,也就是各占一半,现在就让这两堆容量相等,现在遍历所有石头,就看放多少石头最接近容量的一半,均分,最后抵消是最小的
        //也可以说,两堆石头是同时放的,同时放最后分完这堆石头,其中一堆的石头必然  小于等于sum/2;,因为重量要相似,无非就是最后一块石头多出来之类的
        int target = sum/2;
        //外行为背包容量,里面是背包所容纳的最大价值
//        装满容量为j的最大重量
        int[] dp = new int[target+1];
//        dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]。
        //遍历每一个物品

        for (int i = 0; i < stones.length; i++) {
            //内层代表,背包的最大容量
            //只能倒着遍历
            //其实我觉得,从最大容量开始装东西,最后看最大能够盛多少,如果从前往后遍历,现在是一个物品吧,假设  石头的重量为2 那容量为2的时候放进去了,现在容量为4,4-2 =2 是不是容量还有2,是不是又放了一个该物品,所以正着遍历就会重复放
            //倒着遍历.前面的都是还没有放该物品,所以前面的影响不到后面的,这个位置能够放得下就放,对吧.因为你倒着遍历,前面没有放这个物品,还没有轮到,所以就是毫无影响,从最大容量开始放,放得下就放,所以内存循环也很好写,就是当前重量大于等于石头的重量
            for (int j = target; j >=stones[i]; j--) {
                //不放,此时还是等于上次放物品的重量,也就是dp[j]并不改变  j是啥,就是背包容量,背包容量里面的值是不是还是上次存放物品的值呢,没有改变
                //算出target的最大值
                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        //因为target就是最接近总重量一半的值, 最后的重量就是    另一半: sum-dp[target]  减去  这一半  dp[target]
//        sum  -dp[target]-dp[target];   另一半的重量肯定大于或等于,我们算出来的一半最大容量,为啥,因为  int target = sum/2;  这个向下取整
        return sum-2*dp[target];
    }
}
